module ToMidi where

import Musica
import Tiempos
import Composicion
import Funciones

import GeneralMidi
import MidiIO
import Sound.PortMidi

import Data.List(partition)
import Data.Char(toLower,toUpper)
import Codec.Midi

type ProgNum     = Int
type UserPatchMap = [(NombreInstr, Channel)]
makeGMMap :: [NombreInstr] -> UserPatchMap
makeGMMap ins = mkGMMap 0 ins
  where mkGMMap _ []        = []
        mkGMMap n _ | n>=15 = 
                  error "MakeGMMap: Too many instruments."
        mkGMMap n (Percussion : ins)    = 
                  (Percussion, 9) : mkGMMap n ins
        mkGMMap n (i : ins) = 
                  (i, chanList !! n) : mkGMMap (n+1) ins
        chanList = [0..8] ++ [10..15]  -- channel 9 is for percussion
upmLookup :: UserPatchMap  -> NombreInstr 
                           -> (Channel, ProgNum)
upmLookup upm iName = (chan, toGM iName)
  where chan = maybe  (error (  "instrument " ++ show iName ++ 
                                " not in patch map")  )
                      id (lookup iName upm)
toMidi :: Composicion -> UserPatchMap -> Midi
toMidi pf upm =
  let split     = splitByInst pf
      insts     = map fst split
      rightMap  =  if (allValid upm insts) then upm
                   else (makeGMMap insts)
  in Midi  (if length split == 1  then SingleTrack 
                                  else MultiTrack)
           (TicksPerBeat division)
           (map (fromAbsTime . performToMEvs rightMap) split)

division = 96 :: Int
allValid :: UserPatchMap -> [NombreInstr] -> Bool
allValid upm = and . map (lookupB upm)

lookupB :: UserPatchMap -> NombreInstr -> Bool
lookupB upm x = or (map ((== x) . fst) upm)
splitByInst :: Composicion ->  [(NombreInstr,Composicion)]
splitByInst [] = []
splitByInst pf = (i, pf1) : splitByInst pf2
       where i          = nInstr (head pf)
             (pf1, pf2) = partition (\e -> nInstr e == i) pf
type MEvent = (Ticks, Message)

defST = 500000

performToMEvs ::  UserPatchMap
                  -> (NombreInstr, Composicion) 
                  -> [MEvent]
performToMEvs upm (inm, pf) =
  let  (chan,progNum)   = upmLookup upm inm
       setupInst        = (0, ProgramChange chan progNum)
       setTempo         = (0, TempoChange defST)
       loop []      =  []
       loop (e:es)  =  let (mev1,mev2) = mkMEvents chan e
                       in mev1 : insertMEvent mev2 (loop es)
  in setupInst : setTempo : loop pf
mkMEvents :: Channel -> Notas -> (MEvent,MEvent)
mkMEvents  mChan (Notas {  nTiempo = t, nTono = p, 
                           nDur = d, nVol = v})
                  = (  (toDelta t, NoteOn  mChan p v'),
                       (toDelta (t+d), NoteOff mChan p v') )
           where v' = max 0 (min 127 (fromIntegral v))

toDelta t = round (t * 2.0 * fromIntegral division)
insertMEvent :: MEvent -> [MEvent] -> [MEvent]
insertMEvent mev1  []         = [mev1]
insertMEvent mev1@(t1,_) mevs@(mev2@(t2,_):mevs') = 
      if t1 <= t2 then mev1 : mevs
                  else mev2 : insertMEvent mev1 mevs'

defUpm :: UserPatchMap
defUpm = [(DistortionGuitar,1),
          (OverdrivenGuitar,2),
          (AcousticGuitarSteel,3),
          (FretlessBass,4),
          (ElectricBassPicked,5),
          (ElectricBassFingered,6),
          (ElectricGuitarClean,7),
          (RockOrgan,8),
          (AcousticBass,9)]  
            -- the GM name for drums is unimportant, only channel 9

testMidi :: Melodia -> Midi
testMidi m = toMidi (escuchar m) defUpm

test :: Melodia -> IO ()
test     m = exportFile "test.mid" (testMidi m)

play :: Melodia -> IO ()
play = playM . testMidi 
 
playM :: Midi -> IO ()
playM midi = do
  initialize
  (defaultOutput playMidi) midi 
  terminate
  return ()

-- probar Banda
testBanda :: Banda -> IO ()
testBanda banda = let comp = componerBanda banda
                  in exportFile "banda.mid" (toMidi comp defUpm)

escucharBanda :: Banda -> IO ()
escucharBanda = play . joinBanda  
 

